// Code generated by counterfeiter. DO NOT EDIT.
package domainfakes

import (
	"context"
	"realworld-go/domain"
	"realworld-go/domain/model"
	"sync"
)

type FakeArticleRepository struct {
	CreateStub        func(context.Context, model.Article) error
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 context.Context
		arg2 model.Article
	}
	createReturns struct {
		result1 error
	}
	createReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteByIdStub        func(context.Context, model.Article) error
	deleteByIdMutex       sync.RWMutex
	deleteByIdArgsForCall []struct {
		arg1 context.Context
		arg2 model.Article
	}
	deleteByIdReturns struct {
		result1 error
	}
	deleteByIdReturnsOnCall map[int]struct {
		result1 error
	}
	FindAllPaginateStub        func(context.Context, domain.FindAllPaginateArticleParam, ...string) (domain.FindAllArticleResult, error)
	findAllPaginateMutex       sync.RWMutex
	findAllPaginateArgsForCall []struct {
		arg1 context.Context
		arg2 domain.FindAllPaginateArticleParam
		arg3 []string
	}
	findAllPaginateReturns struct {
		result1 domain.FindAllArticleResult
		result2 error
	}
	findAllPaginateReturnsOnCall map[int]struct {
		result1 domain.FindAllArticleResult
		result2 error
	}
	FindOneByOneColumnStub        func(context.Context, domain.FindOneByIdArticleParam, ...string) (domain.FindOneArticleResult, error)
	findOneByOneColumnMutex       sync.RWMutex
	findOneByOneColumnArgsForCall []struct {
		arg1 context.Context
		arg2 domain.FindOneByIdArticleParam
		arg3 []string
	}
	findOneByOneColumnReturns struct {
		result1 domain.FindOneArticleResult
		result2 error
	}
	findOneByOneColumnReturnsOnCall map[int]struct {
		result1 domain.FindOneArticleResult
		result2 error
	}
	UpdateByIdStub        func(context.Context, model.Article, []string) error
	updateByIdMutex       sync.RWMutex
	updateByIdArgsForCall []struct {
		arg1 context.Context
		arg2 model.Article
		arg3 []string
	}
	updateByIdReturns struct {
		result1 error
	}
	updateByIdReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeArticleRepository) Create(arg1 context.Context, arg2 model.Article) error {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 context.Context
		arg2 model.Article
	}{arg1, arg2})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1, arg2})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeArticleRepository) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeArticleRepository) CreateCalls(stub func(context.Context, model.Article) error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeArticleRepository) CreateArgsForCall(i int) (context.Context, model.Article) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeArticleRepository) CreateReturns(result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeArticleRepository) CreateReturnsOnCall(i int, result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeArticleRepository) DeleteById(arg1 context.Context, arg2 model.Article) error {
	fake.deleteByIdMutex.Lock()
	ret, specificReturn := fake.deleteByIdReturnsOnCall[len(fake.deleteByIdArgsForCall)]
	fake.deleteByIdArgsForCall = append(fake.deleteByIdArgsForCall, struct {
		arg1 context.Context
		arg2 model.Article
	}{arg1, arg2})
	stub := fake.DeleteByIdStub
	fakeReturns := fake.deleteByIdReturns
	fake.recordInvocation("DeleteById", []interface{}{arg1, arg2})
	fake.deleteByIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeArticleRepository) DeleteByIdCallCount() int {
	fake.deleteByIdMutex.RLock()
	defer fake.deleteByIdMutex.RUnlock()
	return len(fake.deleteByIdArgsForCall)
}

func (fake *FakeArticleRepository) DeleteByIdCalls(stub func(context.Context, model.Article) error) {
	fake.deleteByIdMutex.Lock()
	defer fake.deleteByIdMutex.Unlock()
	fake.DeleteByIdStub = stub
}

func (fake *FakeArticleRepository) DeleteByIdArgsForCall(i int) (context.Context, model.Article) {
	fake.deleteByIdMutex.RLock()
	defer fake.deleteByIdMutex.RUnlock()
	argsForCall := fake.deleteByIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeArticleRepository) DeleteByIdReturns(result1 error) {
	fake.deleteByIdMutex.Lock()
	defer fake.deleteByIdMutex.Unlock()
	fake.DeleteByIdStub = nil
	fake.deleteByIdReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeArticleRepository) DeleteByIdReturnsOnCall(i int, result1 error) {
	fake.deleteByIdMutex.Lock()
	defer fake.deleteByIdMutex.Unlock()
	fake.DeleteByIdStub = nil
	if fake.deleteByIdReturnsOnCall == nil {
		fake.deleteByIdReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteByIdReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeArticleRepository) FindAllPaginate(arg1 context.Context, arg2 domain.FindAllPaginateArticleParam, arg3 ...string) (domain.FindAllArticleResult, error) {
	fake.findAllPaginateMutex.Lock()
	ret, specificReturn := fake.findAllPaginateReturnsOnCall[len(fake.findAllPaginateArgsForCall)]
	fake.findAllPaginateArgsForCall = append(fake.findAllPaginateArgsForCall, struct {
		arg1 context.Context
		arg2 domain.FindAllPaginateArticleParam
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.FindAllPaginateStub
	fakeReturns := fake.findAllPaginateReturns
	fake.recordInvocation("FindAllPaginate", []interface{}{arg1, arg2, arg3})
	fake.findAllPaginateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeArticleRepository) FindAllPaginateCallCount() int {
	fake.findAllPaginateMutex.RLock()
	defer fake.findAllPaginateMutex.RUnlock()
	return len(fake.findAllPaginateArgsForCall)
}

func (fake *FakeArticleRepository) FindAllPaginateCalls(stub func(context.Context, domain.FindAllPaginateArticleParam, ...string) (domain.FindAllArticleResult, error)) {
	fake.findAllPaginateMutex.Lock()
	defer fake.findAllPaginateMutex.Unlock()
	fake.FindAllPaginateStub = stub
}

func (fake *FakeArticleRepository) FindAllPaginateArgsForCall(i int) (context.Context, domain.FindAllPaginateArticleParam, []string) {
	fake.findAllPaginateMutex.RLock()
	defer fake.findAllPaginateMutex.RUnlock()
	argsForCall := fake.findAllPaginateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeArticleRepository) FindAllPaginateReturns(result1 domain.FindAllArticleResult, result2 error) {
	fake.findAllPaginateMutex.Lock()
	defer fake.findAllPaginateMutex.Unlock()
	fake.FindAllPaginateStub = nil
	fake.findAllPaginateReturns = struct {
		result1 domain.FindAllArticleResult
		result2 error
	}{result1, result2}
}

func (fake *FakeArticleRepository) FindAllPaginateReturnsOnCall(i int, result1 domain.FindAllArticleResult, result2 error) {
	fake.findAllPaginateMutex.Lock()
	defer fake.findAllPaginateMutex.Unlock()
	fake.FindAllPaginateStub = nil
	if fake.findAllPaginateReturnsOnCall == nil {
		fake.findAllPaginateReturnsOnCall = make(map[int]struct {
			result1 domain.FindAllArticleResult
			result2 error
		})
	}
	fake.findAllPaginateReturnsOnCall[i] = struct {
		result1 domain.FindAllArticleResult
		result2 error
	}{result1, result2}
}

func (fake *FakeArticleRepository) FindOneByOneColumn(arg1 context.Context, arg2 domain.FindOneByIdArticleParam, arg3 ...string) (domain.FindOneArticleResult, error) {
	fake.findOneByOneColumnMutex.Lock()
	ret, specificReturn := fake.findOneByOneColumnReturnsOnCall[len(fake.findOneByOneColumnArgsForCall)]
	fake.findOneByOneColumnArgsForCall = append(fake.findOneByOneColumnArgsForCall, struct {
		arg1 context.Context
		arg2 domain.FindOneByIdArticleParam
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.FindOneByOneColumnStub
	fakeReturns := fake.findOneByOneColumnReturns
	fake.recordInvocation("FindOneByOneColumn", []interface{}{arg1, arg2, arg3})
	fake.findOneByOneColumnMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeArticleRepository) FindOneByOneColumnCallCount() int {
	fake.findOneByOneColumnMutex.RLock()
	defer fake.findOneByOneColumnMutex.RUnlock()
	return len(fake.findOneByOneColumnArgsForCall)
}

func (fake *FakeArticleRepository) FindOneByOneColumnCalls(stub func(context.Context, domain.FindOneByIdArticleParam, ...string) (domain.FindOneArticleResult, error)) {
	fake.findOneByOneColumnMutex.Lock()
	defer fake.findOneByOneColumnMutex.Unlock()
	fake.FindOneByOneColumnStub = stub
}

func (fake *FakeArticleRepository) FindOneByOneColumnArgsForCall(i int) (context.Context, domain.FindOneByIdArticleParam, []string) {
	fake.findOneByOneColumnMutex.RLock()
	defer fake.findOneByOneColumnMutex.RUnlock()
	argsForCall := fake.findOneByOneColumnArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeArticleRepository) FindOneByOneColumnReturns(result1 domain.FindOneArticleResult, result2 error) {
	fake.findOneByOneColumnMutex.Lock()
	defer fake.findOneByOneColumnMutex.Unlock()
	fake.FindOneByOneColumnStub = nil
	fake.findOneByOneColumnReturns = struct {
		result1 domain.FindOneArticleResult
		result2 error
	}{result1, result2}
}

func (fake *FakeArticleRepository) FindOneByOneColumnReturnsOnCall(i int, result1 domain.FindOneArticleResult, result2 error) {
	fake.findOneByOneColumnMutex.Lock()
	defer fake.findOneByOneColumnMutex.Unlock()
	fake.FindOneByOneColumnStub = nil
	if fake.findOneByOneColumnReturnsOnCall == nil {
		fake.findOneByOneColumnReturnsOnCall = make(map[int]struct {
			result1 domain.FindOneArticleResult
			result2 error
		})
	}
	fake.findOneByOneColumnReturnsOnCall[i] = struct {
		result1 domain.FindOneArticleResult
		result2 error
	}{result1, result2}
}

func (fake *FakeArticleRepository) UpdateById(arg1 context.Context, arg2 model.Article, arg3 []string) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.updateByIdMutex.Lock()
	ret, specificReturn := fake.updateByIdReturnsOnCall[len(fake.updateByIdArgsForCall)]
	fake.updateByIdArgsForCall = append(fake.updateByIdArgsForCall, struct {
		arg1 context.Context
		arg2 model.Article
		arg3 []string
	}{arg1, arg2, arg3Copy})
	stub := fake.UpdateByIdStub
	fakeReturns := fake.updateByIdReturns
	fake.recordInvocation("UpdateById", []interface{}{arg1, arg2, arg3Copy})
	fake.updateByIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeArticleRepository) UpdateByIdCallCount() int {
	fake.updateByIdMutex.RLock()
	defer fake.updateByIdMutex.RUnlock()
	return len(fake.updateByIdArgsForCall)
}

func (fake *FakeArticleRepository) UpdateByIdCalls(stub func(context.Context, model.Article, []string) error) {
	fake.updateByIdMutex.Lock()
	defer fake.updateByIdMutex.Unlock()
	fake.UpdateByIdStub = stub
}

func (fake *FakeArticleRepository) UpdateByIdArgsForCall(i int) (context.Context, model.Article, []string) {
	fake.updateByIdMutex.RLock()
	defer fake.updateByIdMutex.RUnlock()
	argsForCall := fake.updateByIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeArticleRepository) UpdateByIdReturns(result1 error) {
	fake.updateByIdMutex.Lock()
	defer fake.updateByIdMutex.Unlock()
	fake.UpdateByIdStub = nil
	fake.updateByIdReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeArticleRepository) UpdateByIdReturnsOnCall(i int, result1 error) {
	fake.updateByIdMutex.Lock()
	defer fake.updateByIdMutex.Unlock()
	fake.UpdateByIdStub = nil
	if fake.updateByIdReturnsOnCall == nil {
		fake.updateByIdReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateByIdReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeArticleRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.deleteByIdMutex.RLock()
	defer fake.deleteByIdMutex.RUnlock()
	fake.findAllPaginateMutex.RLock()
	defer fake.findAllPaginateMutex.RUnlock()
	fake.findOneByOneColumnMutex.RLock()
	defer fake.findOneByOneColumnMutex.RUnlock()
	fake.updateByIdMutex.RLock()
	defer fake.updateByIdMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeArticleRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ domain.ArticleRepository = new(FakeArticleRepository)
