// Code generated by counterfeiter. DO NOT EDIT.
package domainfakes

import (
	"context"
	"realworld-go/domain"
	"realworld-go/domain/model"
	"sync"
)

type FakeTagRepository struct {
	DeleteByIDStub        func(context.Context, model.Tag) error
	deleteByIDMutex       sync.RWMutex
	deleteByIDArgsForCall []struct {
		arg1 context.Context
		arg2 model.Tag
	}
	deleteByIDReturns struct {
		result1 error
	}
	deleteByIDReturnsOnCall map[int]struct {
		result1 error
	}
	FindAllByNamesStub        func(context.Context, []string) ([]model.Tag, error)
	findAllByNamesMutex       sync.RWMutex
	findAllByNamesArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	findAllByNamesReturns struct {
		result1 []model.Tag
		result2 error
	}
	findAllByNamesReturnsOnCall map[int]struct {
		result1 []model.Tag
		result2 error
	}
	FindByNameStub        func(context.Context, string) (model.Tag, error)
	findByNameMutex       sync.RWMutex
	findByNameArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	findByNameReturns struct {
		result1 model.Tag
		result2 error
	}
	findByNameReturnsOnCall map[int]struct {
		result1 model.Tag
		result2 error
	}
	FindTagPopulerStub        func(context.Context, int64) ([]domain.FindTagPopulerResult, error)
	findTagPopulerMutex       sync.RWMutex
	findTagPopulerArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	findTagPopulerReturns struct {
		result1 []domain.FindTagPopulerResult
		result2 error
	}
	findTagPopulerReturnsOnCall map[int]struct {
		result1 []domain.FindTagPopulerResult
		result2 error
	}
	UpSertManyStub        func(context.Context, []string) error
	upSertManyMutex       sync.RWMutex
	upSertManyArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	upSertManyReturns struct {
		result1 error
	}
	upSertManyReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTagRepository) DeleteById(arg1 context.Context, arg2 model.Tag) error {
	fake.deleteByIDMutex.Lock()
	ret, specificReturn := fake.deleteByIDReturnsOnCall[len(fake.deleteByIDArgsForCall)]
	fake.deleteByIDArgsForCall = append(fake.deleteByIDArgsForCall, struct {
		arg1 context.Context
		arg2 model.Tag
	}{arg1, arg2})
	stub := fake.DeleteByIDStub
	fakeReturns := fake.deleteByIDReturns
	fake.recordInvocation("DeleteById", []interface{}{arg1, arg2})
	fake.deleteByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTagRepository) DeleteByIDCallCount() int {
	fake.deleteByIDMutex.RLock()
	defer fake.deleteByIDMutex.RUnlock()
	return len(fake.deleteByIDArgsForCall)
}

func (fake *FakeTagRepository) DeleteByIDCalls(stub func(context.Context, model.Tag) error) {
	fake.deleteByIDMutex.Lock()
	defer fake.deleteByIDMutex.Unlock()
	fake.DeleteByIDStub = stub
}

func (fake *FakeTagRepository) DeleteByIDArgsForCall(i int) (context.Context, model.Tag) {
	fake.deleteByIDMutex.RLock()
	defer fake.deleteByIDMutex.RUnlock()
	argsForCall := fake.deleteByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTagRepository) DeleteByIDReturns(result1 error) {
	fake.deleteByIDMutex.Lock()
	defer fake.deleteByIDMutex.Unlock()
	fake.DeleteByIDStub = nil
	fake.deleteByIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTagRepository) DeleteByIDReturnsOnCall(i int, result1 error) {
	fake.deleteByIDMutex.Lock()
	defer fake.deleteByIDMutex.Unlock()
	fake.DeleteByIDStub = nil
	if fake.deleteByIDReturnsOnCall == nil {
		fake.deleteByIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteByIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTagRepository) FindAllByNames(arg1 context.Context, arg2 []string) ([]model.Tag, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.findAllByNamesMutex.Lock()
	ret, specificReturn := fake.findAllByNamesReturnsOnCall[len(fake.findAllByNamesArgsForCall)]
	fake.findAllByNamesArgsForCall = append(fake.findAllByNamesArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.FindAllByNamesStub
	fakeReturns := fake.findAllByNamesReturns
	fake.recordInvocation("FindAllByNames", []interface{}{arg1, arg2Copy})
	fake.findAllByNamesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTagRepository) FindAllByNamesCallCount() int {
	fake.findAllByNamesMutex.RLock()
	defer fake.findAllByNamesMutex.RUnlock()
	return len(fake.findAllByNamesArgsForCall)
}

func (fake *FakeTagRepository) FindAllByNamesCalls(stub func(context.Context, []string) ([]model.Tag, error)) {
	fake.findAllByNamesMutex.Lock()
	defer fake.findAllByNamesMutex.Unlock()
	fake.FindAllByNamesStub = stub
}

func (fake *FakeTagRepository) FindAllByNamesArgsForCall(i int) (context.Context, []string) {
	fake.findAllByNamesMutex.RLock()
	defer fake.findAllByNamesMutex.RUnlock()
	argsForCall := fake.findAllByNamesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTagRepository) FindAllByNamesReturns(result1 []model.Tag, result2 error) {
	fake.findAllByNamesMutex.Lock()
	defer fake.findAllByNamesMutex.Unlock()
	fake.FindAllByNamesStub = nil
	fake.findAllByNamesReturns = struct {
		result1 []model.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeTagRepository) FindAllByNamesReturnsOnCall(i int, result1 []model.Tag, result2 error) {
	fake.findAllByNamesMutex.Lock()
	defer fake.findAllByNamesMutex.Unlock()
	fake.FindAllByNamesStub = nil
	if fake.findAllByNamesReturnsOnCall == nil {
		fake.findAllByNamesReturnsOnCall = make(map[int]struct {
			result1 []model.Tag
			result2 error
		})
	}
	fake.findAllByNamesReturnsOnCall[i] = struct {
		result1 []model.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeTagRepository) FindByName(arg1 context.Context, arg2 string) (model.Tag, error) {
	fake.findByNameMutex.Lock()
	ret, specificReturn := fake.findByNameReturnsOnCall[len(fake.findByNameArgsForCall)]
	fake.findByNameArgsForCall = append(fake.findByNameArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.FindByNameStub
	fakeReturns := fake.findByNameReturns
	fake.recordInvocation("FindByName", []interface{}{arg1, arg2})
	fake.findByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTagRepository) FindByNameCallCount() int {
	fake.findByNameMutex.RLock()
	defer fake.findByNameMutex.RUnlock()
	return len(fake.findByNameArgsForCall)
}

func (fake *FakeTagRepository) FindByNameCalls(stub func(context.Context, string) (model.Tag, error)) {
	fake.findByNameMutex.Lock()
	defer fake.findByNameMutex.Unlock()
	fake.FindByNameStub = stub
}

func (fake *FakeTagRepository) FindByNameArgsForCall(i int) (context.Context, string) {
	fake.findByNameMutex.RLock()
	defer fake.findByNameMutex.RUnlock()
	argsForCall := fake.findByNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTagRepository) FindByNameReturns(result1 model.Tag, result2 error) {
	fake.findByNameMutex.Lock()
	defer fake.findByNameMutex.Unlock()
	fake.FindByNameStub = nil
	fake.findByNameReturns = struct {
		result1 model.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeTagRepository) FindByNameReturnsOnCall(i int, result1 model.Tag, result2 error) {
	fake.findByNameMutex.Lock()
	defer fake.findByNameMutex.Unlock()
	fake.FindByNameStub = nil
	if fake.findByNameReturnsOnCall == nil {
		fake.findByNameReturnsOnCall = make(map[int]struct {
			result1 model.Tag
			result2 error
		})
	}
	fake.findByNameReturnsOnCall[i] = struct {
		result1 model.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeTagRepository) FindTagPopuler(arg1 context.Context, arg2 int64) ([]domain.FindTagPopulerResult, error) {
	fake.findTagPopulerMutex.Lock()
	ret, specificReturn := fake.findTagPopulerReturnsOnCall[len(fake.findTagPopulerArgsForCall)]
	fake.findTagPopulerArgsForCall = append(fake.findTagPopulerArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.FindTagPopulerStub
	fakeReturns := fake.findTagPopulerReturns
	fake.recordInvocation("FindTagPopuler", []interface{}{arg1, arg2})
	fake.findTagPopulerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTagRepository) FindTagPopulerCallCount() int {
	fake.findTagPopulerMutex.RLock()
	defer fake.findTagPopulerMutex.RUnlock()
	return len(fake.findTagPopulerArgsForCall)
}

func (fake *FakeTagRepository) FindTagPopulerCalls(stub func(context.Context, int64) ([]domain.FindTagPopulerResult, error)) {
	fake.findTagPopulerMutex.Lock()
	defer fake.findTagPopulerMutex.Unlock()
	fake.FindTagPopulerStub = stub
}

func (fake *FakeTagRepository) FindTagPopulerArgsForCall(i int) (context.Context, int64) {
	fake.findTagPopulerMutex.RLock()
	defer fake.findTagPopulerMutex.RUnlock()
	argsForCall := fake.findTagPopulerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTagRepository) FindTagPopulerReturns(result1 []domain.FindTagPopulerResult, result2 error) {
	fake.findTagPopulerMutex.Lock()
	defer fake.findTagPopulerMutex.Unlock()
	fake.FindTagPopulerStub = nil
	fake.findTagPopulerReturns = struct {
		result1 []domain.FindTagPopulerResult
		result2 error
	}{result1, result2}
}

func (fake *FakeTagRepository) FindTagPopulerReturnsOnCall(i int, result1 []domain.FindTagPopulerResult, result2 error) {
	fake.findTagPopulerMutex.Lock()
	defer fake.findTagPopulerMutex.Unlock()
	fake.FindTagPopulerStub = nil
	if fake.findTagPopulerReturnsOnCall == nil {
		fake.findTagPopulerReturnsOnCall = make(map[int]struct {
			result1 []domain.FindTagPopulerResult
			result2 error
		})
	}
	fake.findTagPopulerReturnsOnCall[i] = struct {
		result1 []domain.FindTagPopulerResult
		result2 error
	}{result1, result2}
}

func (fake *FakeTagRepository) UpSertMany(arg1 context.Context, arg2 []string) error {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.upSertManyMutex.Lock()
	ret, specificReturn := fake.upSertManyReturnsOnCall[len(fake.upSertManyArgsForCall)]
	fake.upSertManyArgsForCall = append(fake.upSertManyArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.UpSertManyStub
	fakeReturns := fake.upSertManyReturns
	fake.recordInvocation("UpSertMany", []interface{}{arg1, arg2Copy})
	fake.upSertManyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTagRepository) UpSertManyCallCount() int {
	fake.upSertManyMutex.RLock()
	defer fake.upSertManyMutex.RUnlock()
	return len(fake.upSertManyArgsForCall)
}

func (fake *FakeTagRepository) UpSertManyCalls(stub func(context.Context, []string) error) {
	fake.upSertManyMutex.Lock()
	defer fake.upSertManyMutex.Unlock()
	fake.UpSertManyStub = stub
}

func (fake *FakeTagRepository) UpSertManyArgsForCall(i int) (context.Context, []string) {
	fake.upSertManyMutex.RLock()
	defer fake.upSertManyMutex.RUnlock()
	argsForCall := fake.upSertManyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTagRepository) UpSertManyReturns(result1 error) {
	fake.upSertManyMutex.Lock()
	defer fake.upSertManyMutex.Unlock()
	fake.UpSertManyStub = nil
	fake.upSertManyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTagRepository) UpSertManyReturnsOnCall(i int, result1 error) {
	fake.upSertManyMutex.Lock()
	defer fake.upSertManyMutex.Unlock()
	fake.UpSertManyStub = nil
	if fake.upSertManyReturnsOnCall == nil {
		fake.upSertManyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upSertManyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTagRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteByIDMutex.RLock()
	defer fake.deleteByIDMutex.RUnlock()
	fake.findAllByNamesMutex.RLock()
	defer fake.findAllByNamesMutex.RUnlock()
	fake.findByNameMutex.RLock()
	defer fake.findByNameMutex.RUnlock()
	fake.findTagPopulerMutex.RLock()
	defer fake.findTagPopulerMutex.RUnlock()
	fake.upSertManyMutex.RLock()
	defer fake.upSertManyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTagRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ domain.TagRepository = new(FakeTagRepository)
